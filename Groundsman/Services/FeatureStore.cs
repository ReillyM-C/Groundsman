using Groundsman.Interfaces;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using Xamarin.Essentials;

namespace Groundsman.Services
{
    public class FeatureStore : IDataStore<Feature>
    {

        public ObservableCollection<Feature> features;

        public FeatureStore()
        {
            features = new ObservableCollection<Feature>();
        }

        public async Task<bool> AddItemAsync(Feature item)
        {
            //IMPORT CHECKING
            bool parseResult = TryParseFeature(item);
            if (parseResult)
            {
                //EnsureUniqueID(importedFeature);
                features.Add(item);
                var save = SaveFeaturesToFile(features);
            }

            return parseResult;
        }

        public async Task<bool> DeleteItemAsync(Feature item)
        {
            bool deleteSuccessful = features.Remove(item);
            var save = SaveFeaturesToFile(features);
            return save;
        }

        public async Task<bool> DeleteItemsAsync()
        {
            features.Clear();
            int successful = await ImportFeaturesAsync(GetTemplateFile(), false);
            var save = SaveFeaturesToFile(features);
            return save;
        }

        public Task<Feature> GetItemAsync(string id)
        {
            throw new NotImplementedException();
        }

        public async Task<ObservableCollection<Feature>> GetItemsAsync(bool forceRefresh = false)
        {
            if (forceRefresh)
            {
                features.Clear();
                int successful = await ImportFeaturesAsync(GetFeaturesFile(), false);
            }
            return features;
        }

        public async Task<bool> UpdateItemAsync(Feature item)
        {
            // Otherwise we are saving over an existing feature, so override its contents without changing ID.
            for (int i = 0; i < features.Count; i++)
            {
                if (features[i].properties.id == item.properties.id)
                {
                    features[i] = item;
                    return true;
                }
            }
            return false;
        }






        private string GetFeaturesFile()
        {
            if (File.Exists(AppConstants.FEATURES_FILE))
            {
                string text = File.ReadAllText(AppConstants.FEATURES_FILE);
                return text;
            }
            else
            {
                return GetTemplateFile();
            }
        }

        private string GetTemplateFile()
        {
            var assembly = IntrospectionExtensions.GetTypeInfo(GetType()).Assembly;
            Stream stream = assembly.GetManifestResourceStream("Groundsman.locationsAutoGenerated.json");
            string text = "";
            using (var reader = new StreamReader(stream))
            {
                text = reader.ReadToEnd();
            }
            return text;
        }


        //handle notifying errors and success counts where method called from
        private async Task<int> ImportFeaturesAsync(string importContents, bool notify)
        {
            Debug.WriteLine(importContents);
            // Ensure file contents are structured in a valid GeoJSON format.
            GeoJSONObject importedFeaturesData = new GeoJSONObject();
            int successfulImport = 0;
            int failedImport = 0;
            try
            {
                importedFeaturesData = JsonConvert.DeserializeObject<GeoJSONObject>(importContents);
            }
            catch (Exception ex)
            {
                var confirmation = await HomePage.Instance.DisplayAlert("Feature List Error", $"Groundsman has detected that your data is corrupt and cannot be opened. You may copy your data and modify it with an external editor to be GeoJSON compliant then import it again.", "Copy to Clipboard and Erase", "Erase");
                if (confirmation)
                {
                    await Clipboard.SetTextAsync(importContents);
                }
            }

            if (importedFeaturesData != null)
            {
                foreach (Feature importedFeature in importedFeaturesData.features)
                {
                    if (await AddItemAsync(importedFeature))
                    {
                        successfulImport++;
                    }
                    else
                    {
                        failedImport++;
                    }
                }
            }
            return successfulImport;
        }


        private static bool TryParseFeature(Feature feature)
        {
            //if feature is freshly created, no need to parse
            if (feature.properties.id == "-1")
            {
                feature.properties.id = Guid.NewGuid().ToString();
                return true;
            }
            // Ensure the feature has valid GeoJSON fields supplied.
            if (feature != null && feature.type != null && feature.geometry != null && feature.geometry.type != null && feature.geometry.coordinates != null)
            {
                feature.properties.xamarincoordinates = new List<Point>();
                object[] trueCoords;

                // Determine if feature is supported and if so convert its points and add appropriate icon
                switch (feature.geometry.type)
                {
                    case "Point":
                        feature.properties.typeIconPath = "point_icon.png";
                        trueCoords = feature.geometry.coordinates.ToArray();
                        feature.properties.xamarincoordinates.Add(JsonCoordToXamarinPoint(trueCoords));
                        break;
                    case "LineString":
                        feature.properties.typeIconPath = "line_icon.png";
                        // Iterates the root coordinates (List<object>),
                        // then casts each element in the list to a Jarray which contain the actual coordinates.
                        for (int i = 0; i < feature.geometry.coordinates.Count; i++)
                        {
                            trueCoords = ((JArray)feature.geometry.coordinates[i]).ToObject<object[]>();
                            feature.properties.xamarincoordinates.Add(JsonCoordToXamarinPoint(trueCoords));
                        }
                        break;
                    case "Polygon":
                        feature.properties.typeIconPath = "area_icon.png";
                        // Iterates the root coordinates (List<object>), and casts each element in the list to a Jarray, 
                        // then casts each Jarray's element to another Jarray which contain the actual coordinates.
                        for (int i = 0; i < feature.geometry.coordinates.Count; i++)
                        {
                            for (int j = 0, n = ((JArray)feature.geometry.coordinates[i]).Count; j < n; j++)
                            {
                                trueCoords = ((JArray)(((JArray)feature.geometry.coordinates[i])[j])).ToObject<object[]>();
                                feature.properties.xamarincoordinates.Add(JsonCoordToXamarinPoint(trueCoords));
                            }
                        }
                        break;
                    default:
                        return false;
                }
                if (string.IsNullOrWhiteSpace(feature.properties.id))
                {
                    feature.properties.id = Guid.NewGuid().ToString();
                }

                // If author ID hasn't been set on the feature, default it to the user's ID.
                if (string.IsNullOrWhiteSpace(feature.properties.author))
                {
                    feature.properties.author = Preferences.Get("UserID", "Groundsman");
                }

                // Add default name if empty
                if (string.IsNullOrWhiteSpace(feature.properties.name))
                {
                    feature.properties.name = "Unnamed " + feature.geometry.type;
                }

                // If the date field is missing or invalid, convert it into DateTime.Now.
                if (feature.properties.date == null || DateTime.TryParse(feature.properties.date, out _) == false)
                {
                    feature.properties.date = DateTime.Now.ToShortDateString();
                }
                return true;
            }
            return false;
        }

        private static Point JsonCoordToXamarinPoint(object[] coords)
        {
            double longitude = (double)coords[0];
            double latitude = (double)coords[1];
            double altitude = (coords.Length == 3) ? (double)coords[2] : 0.0;

            Point point = new Point(latitude, longitude, altitude);
            return point;
        }

        public bool SaveFeaturesToFile(ObservableCollection<Feature> features)
        {
            GeoJSONObject geoJSONObject = new GeoJSONObject
            {
                type = "FeatureCollection",
                features = features
            };
            var json = JsonConvert.SerializeObject(geoJSONObject);
            File.WriteAllText(AppConstants.FEATURES_FILE, json);
            return true;
        }
    }
}
